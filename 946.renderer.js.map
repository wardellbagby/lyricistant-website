{"version":3,"file":"946.renderer.js","mappings":"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","sources":["webpack://lyricistant/./packages/rhyme-generator/main/rhyme-generator.ts","webpack://lyricistant/./node_modules/comlink/dist/esm/comlink.mjs","webpack://lyricistant/./packages/rhyme-generator/main/rhyme-generator-exports.ts"],"sourcesContent":["import pronunciationsJson from './pronunciations.json';\n\n/** The data structure used in the Pronunciations JSON that will be keyed by a word. */\ntype Pronunciation = [pronunciation: string, popularity?: number];\n\ninterface Rhyme {\n  score: number;\n  word: string;\n}\n\n// Force retype so that the IDE doesn't freak out with the large JSON file.\nconst pronunciations = pronunciationsJson as unknown as Record<\n  string,\n  Pronunciation\n>;\n\nconst cache = new Map<string, Rhyme[]>();\nconst MAX_POPULARITY_SCORE = 100_000;\nconst MAX_RHYMES_COUNT = 100;\nconst MAX_CACHE_COUNT = 100;\n\nexport const generateRhymes = (input: string): Rhyme[] => {\n  if (!input) {\n    return [];\n  }\n\n  input = input.toLowerCase();\n\n  if (cache.has(input)) {\n    return cache.get(input);\n  }\n  const wordPronunciation = pronunciations[input];\n\n  if (!wordPronunciation) {\n    return [];\n  }\n\n  const generatedRhymes: Rhyme[] = [];\n\n  for (const dictWord of Object.keys(pronunciations)) {\n    const match = getBaseWord(dictWord);\n    if (match !== input) {\n      const result = compare(\n        wordPronunciation,\n        pronunciations[dictWord],\n        match\n      );\n      if (result) {\n        generatedRhymes.push(result);\n      }\n    }\n  }\n\n  const results = generatedRhymes\n    .sort((a, b) => b.score - a.score)\n    .slice(0, MAX_RHYMES_COUNT)\n    .filter(\n      (left, index) =>\n        index === generatedRhymes.findIndex((right) => left.word === right.word)\n    );\n\n  cache.set(input, results);\n  if (cache.size > MAX_CACHE_COUNT) {\n    cache.delete(cache.keys().next().value);\n  }\n\n  return results;\n};\n\nconst reverseSyllables = (pronunciation: string) =>\n  pronunciation.split(' ').reverse();\n\nconst removeStress = (syllable: string) => syllable.replace(/[0-9]/g, '');\n\nconst calculateScore = (input: string, match: string) => {\n  const inputSyllables = reverseSyllables(input);\n  const inputStressedIndex = inputSyllables.findIndex((value) =>\n    value.includes('1')\n  );\n  const matchSyllables = reverseSyllables(match);\n  const length = Math.min(inputSyllables.length, matchSyllables.length);\n  let score = 0;\n\n  for (let index = 0; index < length; index++) {\n    const inputSyllable = inputSyllables[index];\n    const matchSyllable = matchSyllables[index];\n\n    if (removeStress(inputSyllable) !== removeStress(matchSyllable)) {\n      if (index <= inputStressedIndex) {\n        // If we don't match up to the first stressed syllable, the rhyme is probably bad.\n        return 0;\n      }\n      break;\n    }\n\n    score += 1;\n    if (inputSyllable.includes('1') && matchSyllable.includes('1')) {\n      // If the same syllable is stressed in both, that's a good sign!\n      score += 1;\n    }\n  }\n\n  if (inputSyllables.length === matchSyllables.length) {\n    score += 1;\n  }\n\n  return score * MAX_POPULARITY_SCORE;\n};\n\nconst compare = (\n  inputPronunciation: Pronunciation,\n  matchPronunciation: Pronunciation,\n  matchWord: string\n) => {\n  let score = calculateScore(inputPronunciation[0], matchPronunciation[0]);\n\n  if (score > 1) {\n    if (matchPronunciation[1]) {\n      /*\n       Popular words should match better than their unpopular peers, but not so\n       well that they match higher than more \"correct\" matches.\n      */\n      score += (MAX_POPULARITY_SCORE - matchPronunciation[1]) / 10;\n    } else {\n      // Unpopular words tend to be pretty weird, so demote them heavy.\n      score -= MAX_POPULARITY_SCORE * 2;\n    }\n    return {\n      score,\n      word: matchWord,\n    };\n  }\n};\n\nconst getBaseWord = (word: string) => {\n  const index = word.indexOf('(');\n  return index < 0 ? word : word.slice(0, index).trim();\n};\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import { generateRhymes } from '@lyricistant/rhyme-generator/rhyme-generator';\nimport { expose } from 'comlink';\n\n// Separate the usage of Comlink from the rhyme-generator itself for easier testing.\nexpose({\n  generateRhymes,\n});\n"],"names":["pronunciations","cache","Map","MAX_POPULARITY_SCORE","reverseSyllables","pronunciation","split","reverse","removeStress","syllable","replace","compare","inputPronunciation","matchPronunciation","matchWord","score","input","match","inputSyllables","inputStressedIndex","findIndex","value","includes","matchSyllables","length","Math","min","index","inputSyllable","matchSyllable","calculateScore","word","getBaseWord","indexOf","slice","trim","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","createProxy","target","serialized","Error","isError","message","name","stack","Object","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","test","isAllowedOrigin","console","warn","id","type","path","argumentList","map","fromWireValue","returnValue","parent","reduce","prop","rawValue","apply","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","TypeError","endpoint","constructor","isMessagePort","close","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","get","isProxyReleased","Proxy","_target","unregister","unregisterProxy","r","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","Array","prototype","concat","handler","serializedValue","msg","fill","floor","random","Number","MAX_SAFE_INTEGER","join","l","generateRhymes","toLowerCase","has","wordPronunciation","generatedRhymes","dictWord","keys","result","push","results","sort","a","b","filter","left","right","size","delete","next"],"sourceRoot":""}